<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="utf-8">
  
  <title>冰箱里的水</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="冰箱里的水">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="冰箱里的水">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="冰箱里的水">
  
    <link rel="alternative" href="/atom.xml" title="冰箱里的水" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  
  
      <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
      <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">
  
  <link rel="stylesheet" href="/css/style.css">
  
      <style> .article { opacity: 0;} </style>
  
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
    
    
  
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <script src="//cdn.bootcss.com/jquery/1.9.1/jquery.min.js"></script>
  <script>
      var yiliaConfig = {
          fancybox: true,
          animate: true,
          isHome: true,
          isPost: false,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false,
      }
  </script>

  
      <script>
          yiliaConfig.rootUrl = "/";
      </script>
  

  

  
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">冰箱里的水</a></h1>
        </hgroup>

        
                


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/newzt" title="GitHub"></a></li>
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:js_zhangtong@163.com" title="Email"></a></li>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">我是一名非著名的JavaScript前端开发者，不断学习！I can do it !</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">冰箱里的水</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">冰箱里的水</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <li id="GitHub"><a class="GitHub" target="_blank" href="https://github.com/newzt" title="GitHub"></a></li>
                            
                                <li id="Email"><a class="Email" target="_blank" href="mailto:js_zhangtong@163.com" title="Email"></a></li>
                            
                        </ul>
            </nav>
        </header>                
    </div>
</nav>
      <div class="body-wrap">
  
    <article id="[layout]-html5shiv解决低版本ie浏览器不支持html5元素的办法" class="article article-type-[layout]" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/19/html5shiv解决低版本ie浏览器不支持html5元素的办法/" class="article-date">
      <time datetime="2016-03-19T12:00:03.000Z" itemprop="datePublished">2016-03-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/19/html5shiv解决低版本ie浏览器不支持html5元素的办法/">html5shiv解决低版本ie浏览器不支持html5元素的办法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p> 低版本ie浏览器不支持html5元素是一个非常正常的事情了，现在也只有高版本浏览器可以支持html5元素了，但现在在国内高版本浏览器不多，如果做一个html5网站要让低版本浏览器也支持我们可以通过html5shiv来解决，具体如下。</p>
<p>八年抗战，html5终于定稿，近年来，随着html5的盛行，我们在页面中也越来越多的运用到html5元素，但是悲催的是，脑残的IE的低版本实在让人抓狂，咱们辛苦规划好的页面在这些IE版别下显得是浆糊一桶。为了让这不一样的IE版别之间能”认识”HTML5元素，开源的html5shiv呈现了！</p>
<p>1、html5shiv的特点</p>
<p>html5shiv的最大特点是让那些个不认HTML5的IE浏览器认出HTML5元素，并依照最基本的处理方法处理HTML5元素——块化（display:block)。这样就阻止了脑残的IE对我们前端人员的残害。</p>
<p>2、html5shiv的使用方法</p>
<p>html5shiv的运用方法非常简略，默许只需要将html5shiv按下面方法放在页面的head内即可。</p>
<pre><code>&lt;!--[if lt IE 9]&gt;
&lt;script src=&quot;dist/html5shiv.min.js&quot;&gt;&lt;/script&gt;
&lt;![endif]--&gt;
</code></pre><p>3、html5shiv的原理</p>
<p>html5shiv的原理是使用createElement方法，这包含document.createElement和document.createDocumentFragment，对当前页面的HTML5元素进行动态的调整，并且为这些元素提供最基本的样式。</p>
<p>4、html5shiv官方给的建议</p>
<p>a.使用min版本的js（压缩过的）以节省带宽和提高加载速度；</p>
<p>b.必须在body元素之前加载；</p>
<p>c.可以在页面的CSS之前或者之后加载，但从性能性能上出发，CSS先于html5shiv加载会更优。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="[layout]-移动端常用META标签总结" class="article article-type-[layout]" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/17/移动端常用META标签总结/" class="article-date">
      <time datetime="2016-03-17T12:00:01.000Z" itemprop="datePublished">2016-03-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/17/移动端常用META标签总结/">移动端常用META标签总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>移动端常用META标签总结</p>
<p>移动端基本上必加的几个标签</p>
<p>声明viewport视口</p>
<p>viewport对于移动端设备来说非常的重要，用于定义视口的各种行为。其中最为重要的就是要设定一个展示页面的宽度width=device-width，如果我们不设置的话，width默认的值是980PX，假设我们当前用的是IPHONE 5来访问H5页面，IPHONE 5本身的宽度只有320PX，但是设备定义了H5页面展示的区域宽度应该是980PX，这样的话要想把H5页面全部进行展示，只有整体缩小大约三倍或者让用户在320PX的区域中来回的挪动才能看全整个H5页面。这种方式用户的体验度会非常的差，所以我们设定width=device-width，意思是当前设备屏幕有多宽，那么就按照多宽来渲染页面，这样就不会出现需要靠缩小或者左右移动来看完整个页面了。</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;/&gt;
</code></pre><p>这里说明一下其它几个属性的作用:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th style="text-align:center">Value</th>
<th style="text-align:right">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>width</td>
<td style="text-align:center">正整数或device-width</td>
<td style="text-align:right">定义视口的宽度，单位为像素</td>
</tr>
<tr>
<td>height</td>
<td style="text-align:center">正整数或device-height</td>
<td style="text-align:right">定义视口的高度，单位为像素</td>
</tr>
<tr>
<td>initial-scale</td>
<td style="text-align:center">[0.0-10.0]</td>
<td style="text-align:right">定义初始缩放值</td>
</tr>
<tr>
<td>minimum-scale</td>
<td style="text-align:center">[0.0-10.0]</td>
<td style="text-align:right">定义缩小最小比例，它必须小于或等于maximum-scale设置</td>
</tr>
<tr>
<td>maximum-scale</td>
<td style="text-align:center">[0.0-10.0]</td>
<td style="text-align:right">定义放大最大比例，它必须大于或等于minimum-scale设置</td>
</tr>
<tr>
<td>user-scalable</td>
<td style="text-align:center">yes/no</td>
<td style="text-align:right">定义是否允许用户手动缩放页面，默认值yes</td>
</tr>
</tbody>
</table>
<p>忽略数字自动识别为电话号码</p>
<p>在IOS Safari（其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接。比如：7位数字，形如：1234567；带括号及加号的数字，形如：(+86)123456789；双连接线的数字，形如：00-00-00111；11位数字，形如：13800138000可能还有其他类型的数字也会被识别，但在具体的业务场景中，有些时候这是不必须的，所以你可以关闭电话自动识别，然后在需要拨号的地方，开启电话呼出和短信功能。</p>
<pre><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;/&gt;
</code></pre><p>开启拨打电话/发送短信功能</p>
<pre><code>&lt;a href=&quot;tel:123456&quot;&gt;立即拨打电话&lt;/a&gt;     &lt;a href=&quot;sms:123456&quot;&gt;立即发送短信&lt;/a&gt;
</code></pre><p>如果同样也需要禁止自动识别邮箱，可以在原来的基础上增加“email=no”。</p>
<pre><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no,email=no&quot;/&gt;
&lt;a href=&quot;mailto:zhufengpeixun@163.com&quot;&gt;给我们发邮件&lt;/a&gt;
</code></pre><p>把页面增加到桌面主屏幕</p>
<p>在苹果手机的Safari浏览器中访问一个页面，用户可以通过“添加到桌面”这一操作把网页保存到自己的主屏幕桌面上（就像安装一个APP，在主屏幕上就会有一个操作的图标），这样下一次可以直接点击图标打开页面。(只对IOS有效)</p>
<p>WebApp全屏模式</p>
<p>当我们将一个网页添加到主屏幕时，会更希望它能有像App一样的表现，没有地址栏和状态栏全屏显示。</p>
<pre><code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;/&gt;
</code></pre><p>设置状态栏颜色</p>
<p>只有在开启WebApp全屏模式下才能起到效果。content的值为 default(状态栏将为正常的，即白色，网页从状态栏以下开始显示) | black(状态栏将为黑色，网页从状态栏以下开始显示) | black-translucent(状态栏将为灰色半透明，网页将充满整个屏幕，状态栏会盖在网页之上)。</p>
<pre><code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot;/&gt;
</code></pre><p>添加到主屏后的图标</p>
<pre><code>&lt;link href=&quot;图片的地址&quot; sizes=&quot;114x114&quot; rel=&quot;apple-touch-icon-precomposed&quot;/&gt;
</code></pre><p>IOS系统中对ICON有一套规范，就是在IOS设备的图标统一为“四边圆角”、“高光处理”。至于“图标阴影”，是IOS设备中统一为所有桌面元素增加的，所以不作为图标单独处理的样式。rel=”apple-touch-icon-precomposed”是设定按照设计稿原图的图标显示，rel=”apple-touch-icon”是设定在原图的基础上增加一些高光光亮效果。一般来说我们的ICON的尺寸是114x114。</p>
<p>添加到主屏后的标题</p>
<pre><code>&lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;标题&quot;/&gt;
</code></pre><p>其它的一些移动端偶尔使用的META标签</p>
<p>添加智能App广告条 Smart App Banner(不常用)</p>
<pre><code>&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL&quot;/&gt;
</code></pre><p>QQ浏览器(X5内核)独有的META</p>
<pre><code>&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait|landscape&quot;/&gt; //-&gt;设置屏幕方向     &lt;meta name=&quot;x5-fullscreen&quot; content=&quot;true&quot;/&gt; //-&gt;设置全屏
</code></pre><p>UC浏览器独有的META</p>
<pre><code>&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait|landscape&quot;/&gt; //-&gt;设置屏幕方向     &lt;meta name=&quot;full-screen&quot; content=&quot;true&quot;/&gt; //-&gt;设置全屏     &lt;meta name=&quot;viewport&quot; content=&quot;uc-fitscreen=no|yes&quot;/&gt; //-&gt;缩放不出现滚动条     &lt;meta name=&quot;nightmode&quot; content=&quot;enable|disable&quot;/&gt; //-&gt;夜间模式
</code></pre><p>强制图片显示：UC浏览器为了节省流量，为用户提供了无图模式，但是如果页面的图片是必不可少的，如验证码的，需要强制浏览器显示图片，可以设置imagemode。通过META设置图片加载方式会作用于整个页面，如果希望对单个图片进行设置，那么可以使用这个<img src="" show="force"></p>
<pre><code>&lt;meta name=&quot;imagemode&quot; content=&quot;force&quot;/&gt;
</code></pre><p>使用了application这种应用模式后，页面讲默认全屏，禁止长按菜单，禁止收拾，标准排版，以及强制图片显示。</p>
<pre><code>&lt;meta name=&quot;browsermode&quot; content=&quot;application&quot;/&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="[layout]-移动端常用META标签" class="article article-type-[layout]" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/17/移动端常用META标签/" class="article-date">
      <time datetime="2016-03-17T12:00:00.000Z" itemprop="datePublished">2016-03-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/17/移动端常用META标签/">移动端常用META标签</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>什么是meta标签?</p>
<p>HTML语言HEAD区的一个辅助性标签，我们通常都在HEAD区域编写一些meta(注意：meta只能写在HEAD区域)，用来提供关于HTML文档的元数据（meta-information），元数据不会显示在页面上，但是对于浏览器是可读取渲染的。它可用于浏览器如何显示内容或重新加载页面，页面SEO优化（关键词和页面描述）等…</p>
<p>meta标签的属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">值</th>
<th style="text-align:right">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>http-equiv</td>
<td style="text-align:center">content-type / expire / refresh / set-cookie</td>
<td style="text-align:right">把content属性关联到HTTP头部</td>
</tr>
<tr>
<td>name</td>
<td style="text-align:center">author / description / keywords / generator / revised …</td>
<td style="text-align:right">把content属性关联到一个名称</td>
</tr>
<tr>
<td>content</td>
<td style="text-align:center">some text</td>
<td style="text-align:right">定义用于翻译content属性值的格式</td>
</tr>
</tbody>
</table>
<p>页面中常用的meat标签总结</p>
<p>一、http-equiv属性</p>
<p>http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。</p>
<p>字符编码：声明文档使用的字符编码</p>
<p>该声明用来指定文档的编码，除了UTF-8(国际通用语言编码,也是最常使用的)，可选值还有：GB2312(简体中文)、BIG5(繁体中文)、iso-2022-jp(日文)、ks_c_5601(韩文)、ISO-8859-1(英文)等</p>
<pre><code>&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=Edge, chrome=1&quot;/&gt;
</code></pre><p>当然，你可能还见过使用以下这种方式来定义文档字符编码。相对于这种方式，更推荐你使用第1种（推荐使用HTML5的声明方式）。</p>
<pre><code>&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8;&quot;/&gt;
</code></pre><p>Expires（期限）</p>
<p>该声明用来指定页面的过期时间，一旦网页过期，从服务器上重新请求，其中时间必须使用GMT格式，或者直接是0（即不缓存）</p>
<pre><code>&lt;meta http-equiv=&quot;expires&quot; content=&quot;Thu Jan 01 1970 00:00:00 GMT 或者 0&quot;/&gt;
</code></pre><p>Pragma(cache模式）</p>
<p>禁止浏览器从本地计算机的缓存中访问页面内容。</p>
<pre><code>&lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot;/&gt;     &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;/&gt;
</code></pre><p>Refresh（刷新）</p>
<p>该声明用来指定页面自刷新或者跳转到其它页面，其中的时间单位是s。第一种写法是10s后刷新本页面，第二种写法是10s后跳转到新的页面。</p>
<pre><code>&lt;meta http-equiv=&quot;refresh&quot; content=&quot;10&quot;/&gt;     &lt;meta http-equiv=&quot;refresh&quot; content=&quot;10; url=...&quot;/&gt;
</code></pre><p>Set-Cookie(cookie设定）</p>
<p>如果网页过期，那么存盘的cookie将被删除。</p>
<pre><code>&lt;meta http-equiv=&quot;set-cookie&quot; content=&quot;[cookie名字]=[cookie值]; expires=[cookie过期时间];path=/;&quot;/&gt;
</code></pre><p>Window-target（显示窗口的设定）</p>
<p>强制页面在当前窗口以独立页面显示。用来防止别人在框架里调用自己的页面。</p>
<pre><code>&lt;meta http-equiv=&quot;window-target&quot; content=&quot;_top&quot;/&gt;
</code></pre><p>声明使用的浏览器及版本</p>
<p>x-ua-compatible设置是从IE8开始增加的（很明显，只适用于IE），对于过往的版本无法识别。开发者可以通过设置x-ua-compatible来指定渲染引擎的类型和版本，并且因为需求不同可以有多种不同的设置。</p>
<pre><code>&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=7&quot;/&gt;     &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=4&quot;/&gt;     &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=50&quot;/&gt;
</code></pre><p>当直接指定content为IE的某个具体版本，如上述代码第1条，客户端的IE将会使用IE7.0标准模式对页面进行渲染，并忽略Doctype定义。当指定的IE版本在客户端IE中不存在时，IE将会尝试将该值转换为最为接近的版本。例如指定一个低于5.0的IE版本，如上述代码第2条，客户端的IE将会使用IE5.0对页面进行渲染，由于IE5.0并没有标准模式，所以将会直接使用quirks mode来渲染；如果指定一个大于客户端IE的版本，如上述代码第3条，假定客户端IE的最高版本为9.0，那么IE会将该值转换为IE=9，即使用IE9.0标准模式对页面进行渲染。</p>
<pre><code>&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=EmulateIE7&quot;/&gt;
</code></pre><p>当指定的content值加了Emulate前缀时，如上述代码，客户端IE将会根据Doctype定义来决定如何来对页面进行渲染。假设页面使用了标准的Doctype，那么此定义效果等同上面的情况；假设页面并没有使用标准的Doctype，那么将使用quirks mode来渲染。</p>
<pre><code>&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=Edge&quot;/&gt;
</code></pre><p>当指定的content值为IE=Edge时，如上述代码，客户端的IE将会使用最高的标准模式对页面进行渲染。</p>
<pre><code>&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=7, 10, 11&quot;/&gt;
</code></pre><p>当指定的content值有多个版本时，如上述代码，假定客户端IE版本为8.0或者9.0，则使用IE7.0标准模式对页面进行渲染；假定客户端IE版本为10.0或者11.0，则直接使用对应版本的标准模式对页面进行渲染。</p>
<pre><code>&lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=Edge, chrome=1&quot;/&gt;
</code></pre><p>当指定的content值为IE=Edge, chrome=1时，如上述代码，假定客户端安装了Google Chrome Frame，则在IE中使用chrome的渲染引擎来渲染页面，否则，将会使用客户端IE最高的标准模式对页面进行渲染。</p>
<p>二、NAME属性</p>
<p>Keywords（关键字）</p>
<p>用来告诉搜索引擎你网页的关键字是什么(这个关键字的设定对于整个页面的SEO优化非常的重要)。一般来说我们会根据当前页面所展示的内容来设定一组关键词语，这样用户在网上进行搜索的时候，搜索引擎会把拥有或者靠近相关关键词的页面呈现给用户，以达到产品推广的作用(当然这个需要长期的SEO/SEM等运营推广才会让自己的网页在搜索出的结果中靠前)。关键字内容太短，搜索引擎可能不会认为和这些内容有关，但是关键字的设定不能超过874个字符。</p>
<pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;javascript培训,js培训,HTML5培训,css培训,前端开发培训,node.js培训,nodeJS培训,移动端培训,北京珠峰培训&quot;/&gt;
</code></pre><p>description（网站内容描述）</p>
<p>用来告诉搜索引擎你的网站主要内容。网站内容描述（description）的设计要点：</p>
<p>①网页描述为自然语言而不是罗列关键词（与keywords设计正好相反）；<br>②尽可能准确地描述网页的核心内容，通常为网页内容的摘要信息，也就是希望搜索引擎在检索结果中展示的摘要信息；<br>③网页描述中含有有效关键词；<br>④网页描述内容与网页标题或者网页主体内容有高度相关性；<br>⑤网页描述的文字不必太多，一般每个网页都应有一个不超过150个字符且能准确反映网页内容的描述标签。<br>     <meta name="description" content="珠峰培训是中国前端开发知名品牌，七年JS前端培训，以专注立身；70%的同学来自老学员推荐，以诚信立业。先学习考试通过后交学费；四周内可无条件退学费；工资不到9千退学费。我们专注的特色培训有：javascript培训,node.JS培训,前端开发培训,HTML5培训,移动端培训"><br>robots（机器人向导）</p>
<p>robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。</p>
<p>content的参数有 all(默认值),none,index,noindex,follow,nofollow。 all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索； nofollow：页面上的链接不可以被查询。</p>
<pre><code>&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt;     &lt;meta name=&quot;google&quot; content=&quot;index,follow&quot;/&gt; -&gt;下面是声明其它搜索引擎的搜索模式     &lt;meta name=&quot;googlebot&quot; content=&quot;index,follow&quot;/&gt;     &lt;meta name=&quot;verify&quot; content=&quot;index,follow&quot;/&gt;
</code></pre><p>声明搜索引擎抓取间隔</p>
<p>有时候你可能并不希望站点一直被搜索引擎抓取，而是每间隔一段时间才来访问一次，这时，可以声明revisit-after meta。</p>
<pre><code>&lt;meta name=&quot;revisit-after&quot; content=&quot;10 days&quot;/&gt;
</code></pre><p>声明网页的作者信息</p>
<pre><code>&lt;meta name=&quot;author&quot; content=&quot;zhufeng,zhufengpeixun@qq.com&quot;/&gt;
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="[layout]-检测浏览器的类型" class="article article-type-[layout]" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/16/检测浏览器的类型/" class="article-date">
      <time datetime="2016-03-16T12:00:02.000Z" itemprop="datePublished">2016-03-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/16/检测浏览器的类型/">检测浏览器的类型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在移动端响应式布局开发过程中，我们经常会遇到：一套项目既要在PC端浏览器上访问，也要在移动端设备的浏览器上访问。目前处理这样的需求有两套解决方案：</p>
<p>1、PC端和移动端共用一套项目</p>
<p>这样的解决方案目前也经常出现，但是前提条件是页面的布局结构相对来说比较的简单，这样即使移动端屏幕比较的窄，我们可以通过类似于把PC端的三列布局改为一列布局的方案或者是宽高自适应缩放等，实现响应式布局的开发。例如：华为官网、猎豹移动都是这样实现的。</p>
<p>2、PC端和移动端使用不同两套项目</p>
<p>第一种解决方案虽然解决了我们的需求，但是一旦页面的结构相对来说复杂一些，我们在进行HTML的排版布局调整，一方面会加大工作量，另外一方面最终排版完成的页面也不方便用户的阅读使用。所以，目前大部分的公司都是PC端单独按照一套排版来做，移动端也会单独的设计一套更符合用户阅读的排版。例如：京东、QQ新闻、淘宝等都是这样处理的。</p>
<p>但是不管是那一套方案，很多时候都需要我们检测出当前页面运行的环境是PC端的浏览器还是移动端的浏览器，尤其是第二套方案，我们要避免用户在PC端打开移动端项目地址，也要避免用户在移动端打开PC端的项目地址，所以检测到底是什么平台环境下的浏览器至关重要。</p>
<p>下面给大家分享的这段代码来自于腾讯新闻部门，他们的团队自己用多台手机进行测试，最终总结出一套相对比较完善的检测代码：</p>
<p>假设PC端项目地址：<a href="http://www.nihao.com/" target="_blank" rel="external">http://www.nihao.com/</a> 移动端项目地址：<a href="http://phone.nihao.com/" target="_blank" rel="external">http://phone.nihao.com/</a></p>
<pre><code>     ~function () {
    var reg1 = /AppleWebKit.*Mobile/i, reg2 = /MIDP|SymbianOS|NOKIA|SAMSUNG|LG|NEC|TCL|Alcatel|BIRD|DBTEL|Dopod|PHILIPS|HAIER|LENOVO|MOT-|Nokia|SonyEricsson|SIE-|Amoi|ZTE/;
//-&gt;条件成立说明当前页面是运行在移动端设备中的         
    if (reg1.test(navigator.userAgent) || reg2.test(navigator.userAgent)) {              //-&gt;如果当前页面的URL是PC端项目的地址:我们需要跳转到移动端项目             
        if (window.location.href.indexOf(&quot;www.nihao.com&quot;) &gt;= 0) {
            window.location.href = &quot;http://phone.zhufengpeixun.cn/&quot;;
        }
        return;
    }
    //-&gt;反之则说明当前的页面是运行在PC端设备中的,如果访问的URL地址是移动端的,我们需要跳转到PC端地址上         
    if (window.location.href.indexOf(&quot;phone.nihao.com&quot;) &gt;= 0) {
        window.location.href = &quot;http://www.zhufengpeixun.cn/&quot;;
    }
}(); 
</code></pre><p>还可以在上述代码的移动端设备中具体的在细分是手机还是PAD，根据需求可以自己选择增加。</p>
<pre><code> ~function () {
var reg1 = /AppleWebKit.*Mobile/i, reg2 = /MIDP|SymbianOS|NOKIA|SAMSUNG|LG|NEC|TCL|Alcatel|BIRD|DBTEL|Dopod|PHILIPS|HAIER|LENOVO|MOT-|Nokia|SonyEricsson|SIE-|Amoi|ZTE/;
if (reg1.test(navigator.userAgent) || reg2.test(navigator.userAgent)) {
    if (/iPad/i.test(navigator.userAgent)) {
        //-&gt;说明是PAD            
    } else {
        // -&gt;说明是手机            
    }
}
}(); 
</code></pre><p>注:以上JS代码应该在JS一加载就开始检测，所以放在头部的HEAD区域。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="[layout]-移动端横竖屏检测" class="article article-type-[layout]" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/16/移动端横竖屏检测/" class="article-date">
      <time datetime="2016-03-16T12:00:00.000Z" itemprop="datePublished">2016-03-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/16/移动端横竖屏检测/">移动端横竖屏检测</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>移动端-横竖屏检测</p>
<p>在移动设备上访问我们的HTML页面，我们很多时候需要根据用户的横竖屏状态做一些操作，例如：我们做了一个H5页面，我们是按照竖屏开发的，当用户切换为横屏幕的时候，宽度变大，高度变小，页面的展示效果不好，此时我们需要进行样式的调整；在例如我们做了一个H5的小游戏，只能让用户横屏玩，当用户切换为竖屏幕的时候我们要给与相关的提示等…</p>
<p>只能检测不能控制</p>
<p>由于我们的HTML5页面是运行在手机浏览器或者Native App的web view中的(详情看Hybrid模式)，而横竖屏切换是手机内部的感应操作，HTML5无法直接的去调取系统级别的API，如果浏览器实现了这个功能，那么H5可以调取，但是目前大部分的浏览器都不支持；而且横竖屏的操控本身也有诸多的限制，比如用户禁止了横竖屏的切换，那么还是无法进行切换的…</p>
<p>所以要记住，HTML5可以检测出用户当前是横屏还是竖屏，但是不能禁止横竖屏的切换（如果浏览器提供了相关的功能，我们可以控制，例如：QQ和UC就实现了这个功能，我们可以通过设置META来控制横竖屏）</p>
<pre><code>//-&gt;QQ X5内核
&lt;meta name=&quot;x5-orientation&quot; content=&quot;portrait|landscape&quot;/&gt;

//-&gt;UC浏览器
&lt;meta name=&quot;screen-orientation&quot; content=&quot;portrait|landscape&quot;/&gt;
</code></pre><p>点击查看更多的移动端META标签使用<br>在CSS3中检测</p>
<p>在CSS3中我们使用@MEDIA媒体查询进行检测，检测出来后可以进行样式的调整。</p>
<pre><code>@media all and (orientation: landscape) {
    /*横屏*/
    body {
        background: blue;
    }
}

@media all and (orientation: portrait) {
    /*竖屏*/
    body {
        background: green;
    }
}
</code></pre><p>在JS中检测</p>
<p>在JS代码中我们可以使用orientationchange事件进行检测，检测出来后可以在JS中给予相关的提示。(在安卓机器上当切换完成后需要等待一段时间才能反应过来)</p>
<pre><code>~function () {
    window.addEventListener(&quot;orientationchange&quot;, function (ev) {
        console.log(ev.orientation);
    }, false);
}();
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="[layout]-flexbox理解" class="article article-type-[layout]" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/09/flexbox理解/" class="article-date">
      <time datetime="2016-03-09T12:00:02.000Z" itemprop="datePublished">2016-03-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/09/flexbox理解/">flexbox理解</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>flexbox的优势</p>
<p>随着移动设备的普及,各种响应式用户界面的流行,Web 应用一般都要求适配不同的设备尺寸和浏览器分辨率,这无疑使布局的逻辑变得更加复杂.<br>我们需要根据窗口尺寸来调整布局，从而改变组件的尺寸和位置，以达到最佳的显示效果</p>
<p>CSS3 规范中引入的新布局模型：弹性盒模型（flex box）。弹性盒模型可以用简单的方式满足很多常见的复杂的布局需求,它能以更加高效的方式来对容器中的盒子进行布局、对齐和分配空间,即使盒子尺寸未知或动态时也能工作</p>
<p>flexbox的属性</p>
<p>通过flexbox来布局可以轻松实现各种负责的布局,并且提供的属性不是很多,学习难度一般,归纳下,主要有如下几个属性(以下写的都是2012版提供的标准写法,):</p>
<p>在这之前如果你对主轴与交叉轴的概念或者对每个属性有哪些值还不是很清楚,请看上一篇文章flexbox基础知识入门</p>
<pre><code> display:flex;
 flex-direcition 确定主轴的方向
 flex-wrap 当子容器超出父容器时如何排列
 flex-flow 是flex-direction和flex-wrap的复合属性
 order 作用在子容器上,用来改变子容器的排列顺序,值越小,排列越靠前
 justify-content 在主轴的排列方式
 align-items 在交叉轴的排列方式
 align-content  在交叉轴方向上的空白处理,但如果又只有单行时,该属性不起作用
 align-self 设置子容器覆盖父容器指定的对齐方式,如果子容器margin值设为auto,则不起作用

最后三个是比较重要的,也是弹性盒模型的核心之处,弹性的处理盒子的尺寸
细分属性:flex-grow   flex-shrink flex-basis
上者三个的复合属性:flex

flex-grow 有多余空间时,该值起作用
flex-shrink 有溢出空间时,该值起作用
flex-basis 子容器被调整之前的初始值  
</code></pre><p>flex组合写法的总结</p>
<pre><code>flex:atuo -&gt;flex:1 1 atuo
flex:none -&gt; flex:0 0 auto
flex:1 -&gt; flex:1 1 0%
flex:0% -&gt; flex:1 1 0%
flex: 2 100px -&gt;flex: 2 1 100px 
</code></pre><p>flexbox的实例</p>
<p>1.网格布局 就是平均分布。在容器里面平均分配空间 ,但需要项目自动缩放,自动缩放这点是把flex-basis设置成了auto来实现的,当前也可以对部分元素设置百分比,其他的子容器平均分配多余的空间</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;item&quot;&gt;...&lt;/div&gt;
  &lt;div class=&quot;item&quot;&gt;...&lt;/div&gt;
  &lt;div class=&quot;item&quot;&gt;...&lt;/div&gt;
&lt;/div&gt;
&lt;style type=&quot;text/css&quot;&gt; 
.container{
  display: flex;
}

.item {
  flex: 1;
}
&lt;/style&gt;
</code></pre><p>2.常见的三栏布局</p>
<pre><code>html部分:
&lt;div class=&quot;wrapper&quot;&gt;
    &lt;header class=&quot;header&quot;&gt;Header&lt;/header&gt;
    &lt;article class=&quot;main&quot;&gt;
        &lt;p&gt;Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo.&lt;/p&gt;
    &lt;/article&gt;
    &lt;aside class=&quot;aside aside-1&quot;&gt;Aside 1&lt;/aside&gt;
    &lt;aside class=&quot;aside aside-2&quot;&gt;Aside 2&lt;/aside&gt;
    &lt;footer class=&quot;footer&quot;&gt;Footer&lt;/footer&gt;
&lt;/div&gt;

 css部分:
     &lt;style type=&quot;text/css&quot;&gt;
        .wrapper {
            display: -webkit-box;
            display: -moz-box;
            display: -ms-flexbox;
            display: -webkit-flex;
            display: flex;
            -webkit-flex-flow: row wrap;
            flex-flow: row wrap;
            font-weight: bold;
            text-align: center;
        }

        .wrapper &gt; * {
            padding: 10px;
            flex:1 100%;

        }

        .header {
            background: tomato;
        }

        .footer {
            background: lightgreen;
        }

        .main {
            text-align: left;
            background: deepskyblue;
        }

        .aside-1 {
            background: gold;
        }

        .aside-2 {
            background: hotpink;
        }

        @media all and (min-width: 800px) {
        .main    { flex: 3 0%; }

        .aside-1 { order: 1; }
        .main    { order: 2; }
        .aside-2 { order: 3; }
        .footer  { order: 4; }
        }

        @media all and (min-width: 600px) {
            .aside { flex: 1 auto;}
        }

    &lt;/style&gt;
</code></pre><p>3.输入框的布局<br>我们常常需要在输入框的前方添加提示，后方添加按钮。</p>
<pre><code>html部分:

&lt;div class=&quot;InputBox&quot;&gt;
  &lt;span class=&quot;InputBox-item&quot;&gt;...&lt;/span&gt;
  &lt;input class=&quot;InputBox-field&quot;&gt;
  &lt;button class=&quot;InputBox-item&quot;&gt;...&lt;/button&gt;
&lt;/div&gt;

css部分:
.InputBox{
  display: flex;
}

.InputBox-field {
  flex: 1;
}
</code></pre><p>4.流式布局或或垂直居中等</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="[layout]-LESS语言特性" class="article article-type-[layout]" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/01/LESS语言特性/" class="article-date">
      <time datetime="2016-03-01T12:00:03.000Z" itemprop="datePublished">2016-03-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/01/LESS语言特性/">LESS语言特性</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>概述</p>
<p>作为一种 CSS 扩展, Less 不仅向后兼容 CSS, 它还使用现有的 CSS 语法新增了额外的特性. 这使得学习 Less 更轻松, 一旦有任何问题，可以随时退回使用标准的 CSS.</p>
<p>Variables (变量)</p>
<p>管理重复值</p>
<pre><code>@nice-blue: #5B83AD;
@light-blue: @nice-blue + #111;
#header {
color: @light-blue;
}
</code></pre><p>除了使用变量管理值,还可以用在其他地方,例如选择器,属性名,url,@import语句中</p>
<pre><code>//选择器
@mySelector : banner;
.@{mySelector}{
    font-weight: bold;
    line-height: 40px;
    margin: 0 auto;
}
//url
@images: &quot;../img&quot;;

//属性
@property:color;
.widget{
    @{property}:#0ee;
    background-@{property}:#999
}
//使用变量定义变量名
@fnord:&quot;I am fnord&quot;;
@var :&quot;fnord&quot;;
content:@@var;

//变量不一定要提前申明
.lazy-eval{
    width:@var;
}
@var :@a;
@a:9%

//变量先在当前作用域查找,没有再去往上一级查找
@var:0;
.class{
   @var: 1;
  .brass {
    @var: 2;
    three: @var;
    @var: 3;
  }
  one: @var;
}
//编译为
.class {
    one:1;
}
.class .brass{
    three:3;
}
</code></pre><p>Extend (扩展)</p>
<p>不同选择器公用相同的样式,避免添加基础类<br>    nav ul {<br>      &amp;:extend(.inline);<br>      background: blue;<br>    }<br>    //编译为<br>    nav ul {<br>      background: blue;<br>    }<br>    .inline,<br>    nav ul {<br>      color: red;<br>    }</p>
<p>规则集内的扩展</p>
<pre><code>pre:hover,
.some-class {
  &amp;:extend(div pre);
}
//与下面的写法相同
pre:hover:extend(div pre),
.some-class:extend(div pre) {}
</code></pre><p>扩展多个类,使用逗号分割</p>
<pre><code>.e:extend(.f) {}
.e:extend(.g) {}
//上面的代码与下面做的事情一样
.e:extend(.f, .g) {}
</code></pre><p>编写在media声明内的extend也应该只匹配同一media声明内的选择器</p>
<pre><code>@media print {
  .screenClass:extend(.selector) {} // media内的extend
  .selector { // 这个会匹配到-因为在同一的media内
    color: black;
  }
}
.selector { // 定义样式表中的规则 - extend会忽略它
  color: red;
}
@media screen {
  .selector {  // 另一个media声明内的规则 - extend也会忽略它
    color: blue;
  }
}
</code></pre><p>编写在media声明内的extend不会匹配嵌套声明内的选择器</p>
<pre><code>@media screen{
    .screenClass:extend(.selector){}
    @media (min-width:1023px){
        .selector{color:blue};//嵌套media内的规则-extend会忽视它
    }
}
</code></pre><p>顶级extend匹配一切，包括media嵌套内的选择器</p>
<pre><code>@media screen {
  .selector {  /* media嵌套内的规则 - 顶级extend正常工作 */
    color: blue;
  }
  @media (min-width: 1023px) {
    .selector {  /* media嵌套内的规则 - 顶级extend正常工作 */
      color: blue;
    }
  }
}

.topLevel:extend(.selector) {} /* 顶级extend匹配一切 */
</code></pre><p>Mixins (混合)</p>
<p>不同的选择器之间可以相互调用,调用时,括号可加可不加</p>
<pre><code>.a, #b {
  color: red;
}
.mixin-class {
  .a();
}
.mixin-id {
  #b();
}
</code></pre><p>混合集不仅可以包含各种属性,还可以包括各种选择器</p>
<pre><code>.my-hover-mixin() {
  &amp;:hover {
    border: 1px solid red;
  }
}
button {
  .my-hover-mixin();
}
</code></pre><p>(命名空间 ) 可以将属性嵌套到比较复杂的选择器中,可以嵌套id或class</p>
<pre><code> #outer {
  .inner {
    color: red;
  }
}

.c {
  #outer &gt; .inner; //调用时建议使用这种方式,当然&gt;是可选的
}
// 下面四种写法效果是一样的
#outer &gt; .inner;
#outer &gt; .inner();
#outer.inner;
#outer.inner();
//把混合集放到一个id选择器里面，这样可以确保它（这个混合集）不会跟其他的库冲突。
</code></pre><p>调用的混合集后面追加 !important 关键字，可以使混合集里面的所有属性都继承 !important：</p>
<pre><code>.foo{
    color:#333;
    background:#555
}
.important{
    .foo() !important ;
}
//结果为:
.important {
  background: #555 !important;
  color: #333 !important;
}
</code></pre><p>带参数的混合</p>
<pre><code>.border-radius(@radius:5px) {//可以给参数设置初始值
  -webkit-border-radius: @radius;
     -moz-border-radius: @radius;
          border-radius: @radius;
}
//设置初始值后就可以像这样调用它
#header{
    .border-radius  
}
</code></pre><p>可以使用不接受参数的混合 ,如果想在输出的CSS中隐藏规则集,但又想使用规则集中的属性,则这个特性很有用</p>
<pre><code>.wrap() {
  text-wrap: wrap;
  white-space: -moz-pre-wrap;
  white-space: pre-wrap;
  word-wrap: break-word;
}

pre { .wrap }
//输出
pre {
  text-wrap: wrap;
  white-space: -moz-pre-wrap;
  white-space: pre-wrap;
  word-wrap: break-word;
}
</code></pre><p>带多个参数的mixins</p>
<pre><code>.mixin(@color; @padding; @margin: 2) {
  color-3: @color;
  padding-3: @padding;
  margin: @margin @margin @margin @margin;
}
.some .selector div {
  .mixin(#008000);
}
//注:任何参数都已通过它的名称来引用，这样就不必按照任意特定的顺序来使用参数
</code></pre><p>多个参数统一设置还可以使用@arguments 变量</p>
<pre><code> .transition(@property:all,@duration;@timing-function;@delay){

 -webkit-transition:@property @duration @timing-function @delay;
    -moz-transition:@property @duration @timing-function @delay;
     -ms-transition:@property @duration @timing-function @delay;
      -o-transition:@property @duration @timing-function @delay;
         transition:@property @duration @timing-function @delay;
}

//上面可以简写成如下
.transition(@property:all,@duration;@timing-function;@delay){   
    -webkit-transition:@arguments;
       -moz-transition:@arguments;
        -ms-transition:@arguments;
         -o-transition:@arguments;
            transition:@arguments;
}
</code></pre><p>接收数量不定的参数 ,可以使用 … ,在变量名后面使用它,它会将这些参数分配给变量</p>
<pre><code> .mixin(...) {        // matches 0-N arguments
.mixin() {           // matches exactly 0 arguments
.mixin(@a: 1) {      // matches 0-1 arguments
.mixin(@a: 1; ...) { // matches 0-N arguments
.mixin(@a; ...) {    // matches 1-N arguments

//此外
.mixin(@a; @rest...) {
   // @rest is bound to arguments after @a
   // @arguments is bound to all arguments
}
</code></pre><p>匹配模式<br>根据不同的参数,设定不同的行为</p>
<pre><code>@switch:light
.mixin(dark,@color){
    color : darken(@color:10%);
}
.mixin(light,@color){
    color : lighten(@color:10%);
}
.mixin(@_,@color){ //匹配任意值,但要注意@color必须写
    display:block;
}
.a{
    .mixin(@switch,#333);
}   
注:也可以基于参数个人来匹配
</code></pre><p>作为函数使用的混合<br>在类似函数的mixin中,变量会充当它的返回值</p>
<pre><code> .mixin() {
  @width:  100%;
  @height: 200px;
}

.caller {
  .mixin(); //先运行
  width:  @width; //调用返回值
  height: @height;
}
//结果:
.caller{
    width:100%;
    height:200%;
}
</code></pre><p>带参数的函数混合</p>
<pre><code> .average(@x, @y) {
  @average: ((@x + @y) / 2);
}

div {
  .average(16px, 50px); // &quot;call&quot; the mixin
  padding: @average;    // use its &quot;return&quot; value
}
</code></pre><p>定义在mixin中的mixin同样可以作为返回值</p>
<pre><code>.unlock(@value) { // 外层的 mixin
  .doSomething() { // 被嵌套的 mixin
    declaration: @value;
  }
}

#namespace {
  .unlock(5); // unlock doSomething mixin
  .doSomething(); //嵌套混入被复制到这里，并可用
}
#namespace {
  declaration: 5;
}
</code></pre><p>在mixin中定义包装的CSS代码块</p>
<pre><code>// 声明 detached 规则集合
@detached-ruleset: { background: red; };

// 使用 detached 规则集合
.top {
    @detached-ruleset();  //()这个括号是必须写的
}
//结果为:
.top {
  background: red;
}
</code></pre><p>导入规则</p>
<pre><code>从其他样式表中导入样式。

在标准的CSS中，@import必须在所有其他类型的规则之前。但是Less.js不在乎你把@import语句放在什么位置。
</code></pre><p>File extensions （文件扩展名）</p>
<pre><code>如果文件有一个.css扩展名，则将它作为CSS对象,其他的则作为Less文件导入进来
</code></pre><p>Import (导入选项)</p>
<pre><code>语法：@import (keyword) “filename”;

reference：使用Less文件但不输出 
inline：在输出中包含源文件但不加工它 
less：将文件作为Less文件对象，无论是什么文件扩展名 
css：将文件作为CSS文件对象，无论是什么文件扩展名 
once：只包含文件一次（默认行为） 
multiple：包含文件多次
</code></pre><p>Mixin Guards (带条件的mixins)</p>
<pre><code>.mixin (@a) when (lightness(@a) &gt;= 50%) {
  background-color: black;
}
.mixin (@a) when (lightness(@a) &lt; 50%) {
  background-color: white;
}
.mixin (@a) {
  color: @a;
}
.class1 { .mixin(#ddd) }
.class2 { .mixin(#555) }

//输出
.class1 {
  background-color: black;
  color: #ddd;
}
.class2 {
  background-color: white;
  color: #555;
}
</code></pre><p>Guard中的比较运算符 (&gt;,&gt;=,=, =&lt;,&lt;) ,此外,关键字true,是让两个mixins等价的唯一真值</p>
<pre><code>.truth (@a) when (@a) { ... }
.truth (@a) when (@a = true) { ... }//除了关键字true，其他任何值都是假值：
</code></pre><p>注意，你也可以比较其他每个参数或者不使用参数</p>
<pre><code>@media: mobile;
.mixin (@a) when (@media = mobile) { ... }
.mixin (@a) when (@media = desktop) { ... }

.max (@a; @b) when (@a &gt; @b) { width: @a }
.max (@a; @b) when (@a &lt; @b) { width: @b }
</code></pre><p>Guard逻辑运算符<br>您可以在guards之间使用逻辑运算符。语法是基于CSS媒体查询。<br>使用and关键字来组合guards：</p>
<pre><code>.mixin (@a) when (isnumber(@a)) and (@a &gt; 0) { ... }
</code></pre><p>你可以通过用逗号 , 分隔guards来模仿 or 运算符。如果任何 guards 为 true，那么它认为是匹配的：</p>
<pre><code>.mixin (@a) when (@a &gt; 10), (@a &lt; -10) { ... }
</code></pre><p>使用 not 关键字来否定条件：</p>
<pre><code>.mixin (@b) when not (@b &gt; 0) { ... }
</code></pre><p>类型检查函数<br>基本的类型检查函数<br>iscolor<br>isnumber<br>isstring<br>iskeyword<br>isurl<br>你想检查一个值除了数字是否是一个特定的单位，你可以使用下列方法之一<br>ispixel<br>ispercentage<br>isem<br>isunit<br>你还可以通过与&amp;特性结合实现’if’类型的语句，从而允许组合多个约束。</p>
<pre><code>&amp; when (@my-option = true) {
  button {
    color: white;
  }
  a {
    color: blue;
  }
}
</code></pre><p>Loops （循环）</p>
<p>使用递归循环最常见的情况就是生成栅格系统的CSS：</p>
<pre><code>.loop(@counter) when (@counter &gt; 0) {
  .loop((@counter - 1));    // 递归调用自身
  width: (10px * @counter); // 每次调用时产生的样式代码
}

div {
  .loop(5); // 调用循环
}

//结果
div {
  width: 10px;
  width: 20px;
  width: 30px;
  width: 40px;
  width: 50px;
}
</code></pre><p>使用递归循环最常见的情况就是生成栅格系统的CSS：</p>
<pre><code>.generate-columns(4);

.generate-columns(@n, @i: 1) when (@i =&lt; @n) {
  .column-@{i} {
    width: (@i * 100% / @n);
  }
  .generate-columns(@n, (@i + 1));
}
输出:
.column-1 {
  width: 25%;
}
.column-2 {
  width: 50%;
}
.column-3 {
  width: 75%;
}
.column-4 {
  width: 100%;
}
</code></pre><p>Merge (合并)</p>
<p>从多个属性中将值集合到一个单一属性之下的逗号或空格分割属性列表中。对于诸如background和transform之类的属性来说，merge非常有用。</p>
<pre><code>.mixin() {
  box-shadow+: inset 0 0 10px #555;
}
.myclass {
  .mixin();
  box-shadow+: 0 0 20px black;
}
//输出
.myclass {
  box-shadow: inset 0 0 10px #555, 0 0 20px black;
}

.mixin() {
  transform+_: scale(2);
}
.myclass {
  .mixin();
  transform+_: rotate(15deg);
}

//输出
.myclass {
  transform: scale(2) rotate(15deg);
}
</code></pre><p>为避免任何非有意的添加，merge需要在每个待加入的声明中显示的设置一个+或者+_标记</p>
<p>Parent Selectors （父级选择器)</p>
<p>&amp; 运算符表示一个 嵌套规则 的父选择器，它在应用修改类或者应用伪类给现有选择器时最常用：</p>
<pre><code>a {
  color: blue;
  &amp;:hover {
    color: green;
  }
}

//输出
a {
  color: blue;
}

a:hover {
  color: green;
}


.link {
  &amp; + &amp; {
    color: red;
  }

  &amp; &amp; {
    color: green;
  }

  &amp;&amp; {
    color: blue;
  }

  &amp;, &amp;ish {
    color: cyan;
  }
}
//输出

.link + .link {
  color: red;
}
.link .link {
  color: green;
}
.link.link {
  color: blue;
}
.link, .linkish {
  color: cyan;
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="[layout]-LESS基础语法" class="article article-type-[layout]" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/01/LESS基础语法/" class="article-date">
      <time datetime="2016-03-01T12:00:02.000Z" itemprop="datePublished">2016-03-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/01/LESS基础语法/">LESS基础语法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>LESS基础语法</p>
<p>我们一起来学习一下LESS的基础语法，LESS的基础语法基本上分为以下几个方面：变量、混合(Mixins)、嵌套规则、运算、函数、作用域等。这些基础语法需要我们先牢牢的掌握住，然后才可以灵活的在项目中进行实战。</p>
<p>变量</p>
<p>和JS中的变量一样，只是LESS的变量定义不是使用VAR而是使用@。</p>
<pre><code>//-&gt;LESS代码
@link-color: #428bca;
@link-color-hover: darken(@link-color, 10%);

a {
    color: @link-color;
    &amp;:hover {
        color: @link-color-hover;
    }
}

.box {
    color: @link-color;
}

//-&gt;编译为CSS的结果
a {
    color: #428bca;
}

a:hover {
    color: #3071a9;
}

.box {
    color: #428bca;
}
</code></pre><p>除了上述用变量存储公用的属性值，我们还可以用变量存储公用的URL、选择器等等</p>
<pre><code>//-&gt;LESS代码
.@{selector} {
    width: 100px;
    height: 100px;
    @{property}: #000;
    background: url(&quot;@{bgImg}/test.png&quot;);

    &amp;:after {
        display: block;
        content: @@var;
    }
}
@selector: box;
@bgImg: &quot;../img&quot;;
@property: color;
@name: &quot;珠峰培训&quot;;
@var: &quot;name&quot;;

//-&gt;编译为CSS的结果
.box {
    width: 100px;
    height: 100px;
    color: #000;
    background: url(&quot;../img/test.png&quot;);
}

.box:after {
    display: block;
    content: &quot;珠峰培训&quot;;
}
</code></pre><p>在上述的代码中我们发现，变量存储的值可以作为选择器，也可以作为样式属性名，同样也可以像类似于JS中字符串拼接的方式把变量值的和另外一个字符串进行拼接，而且@@var是把var变量存储的值作为另外一个变量的名从而获取对应的值。还有一点值的我们注意的是，变量可以定在使用代码的下面，这个有点类似于JS中的预解释，不管写在上面还是下面，都是相当于全局的变量，并且都可以把存储值获取到(但是建议大家把变量都统一在最上面定义)。</p>
<p>Mixin混合</p>
<p>1、基本使用</p>
<p>从字面意思上理解，所谓的混合其实应该是把很多的样式混合在一起，这样理解不准确，个人的理解，所谓的混合其实是把某个选择器中的样式拿过来使用，我们看下面的代码。</p>
<pre><code>//-&gt;LESS代码
.public {
    width: 100px;
    height: 100px;
}

nav ul {
    .public;
    list-style: none;
}

//-&gt;编译为CSS的结果
.public {
    width: 100px;
    height: 100px;
}

nav ul {
    width: 100px;
    height: 100px;
    list-style: none;
}
</code></pre><p>观察上述的代码，我们发现其实nav ul是把public中设定的样式属性值copy了一份到自己的样式中。如果你想在编译完成的结果中不输出public这个样式的结果，只需要按照下述的代码编写即可：</p>
<pre><code>//-&gt;LESS代码
.public() {//-&gt;在选择器后面加上()就可以不编译这个样式了
    width: 100px;
    height: 100px;
}

nav ul {
    .public;
    list-style: none;
}

//-&gt;编译为CSS的结果
nav ul {
    width: 100px;
    height: 100px;
    list-style: none;
}
</code></pre><p>2、Extend</p>
<p>虽然在上述的案例中，nav ul把public中的样式继承了过来，但是原理却是把代码copy一份过来，这样编译后的CSS中依然会存留大量的冗余CSS代码，为了避免这一点，我们可以使用extend伪类来实现样式的继承使用。</p>
<pre><code>//-&gt;LESS代码
.public {
    width: 100px;
    height: 100px;
}

nav ul {
    &amp;:extend(.public);
    list-style: none;
}

//-&gt;编译为CSS的结果
.public, nav ul {
    width: 100px;
    height: 100px;
}

nav ul {
    list-style: none;
}
</code></pre><p>或者：</p>
<pre><code>//-&gt;LESS代码
.public {
    width: 100px;
    height: 100px;
}

nav ul:extend(.public) {
    list-style: none;
}

//-&gt;编译为CSS的结果和第一种写法一样
</code></pre><p>3、命名空间和作用域</p>
<p>在LESS的语法中，我们可以指定命名空间，实现在一个盒子中层级嵌套式的编写。下面案例中，.box就是命名空间，里面的img、.gray都是这个空间下的样式，调取的话需要.box &gt; .gray。</p>
<pre><code>//-&gt;LESS代码
.box {
    width: 100px;
    height: 100px;
    img {
        width: 100%;
        height: 100%;
    }
    .gray {
        color: #eee;
    }
    &amp;:hover {
        background: green;
    }
}

#nav {
    .box;
}

#header {
    .box &gt; .gray;
}

//-&gt;编译为CSS的结果
.box {
    width: 100px;
    height: 100px;
}

.box img {
    width: 100%;
    height: 100%;
}

.box .gray {
    color: #eee;
}

.box:hover {
    background: green;
}

#nav {
    width: 100px;
    height: 100px;
}

#nav img {
    width: 100%;
    height: 100%;
}

#nav .gray {
    color: #eee;
}

#nav:hover {
    background: green;
}

#header {
    color: #eee;
}
</code></pre><p>在LESS中定义了命名空间就创建了一个私有的作用域，在这个私有作用域中使用的变量都是先看一下自己作用域中有没有，没有的话，在向上一级查找（类似于JS的作用域链）。</p>
<pre><code>//-&gt;LESS代码
@color: #ccc;
.box {
    @color: #eee;
    .gray {
        color: @color;
    }
}

.box2 {
    .gray {
        color: @color;
    }
}

//-&gt;编译为CSS的结果
.box .gray {
    color: #eee;
}

.box2 .gray {
    color: #ccc;
}
</code></pre><p>4、!important</p>
<p>在调用的混合集后面追加 !important 关键字，可以使混合集里面的所有属性都继承 !important:</p>
<pre><code>//-&gt;LESS代码
@color: #ccc;
.box {
  @color: #eee;
  .gray {
    color: @color;
  }
}

nav ul {
  .box !important;
}

//-&gt;编译为CSS的结果
.box .gray {
    color: #eee;
}

nav ul .gray {
    color: #eee !important;
}
</code></pre><p>5、Parametric Mixins</p>
<p>如同JS一样，LESS也可以向函数一样设定形参数，这个技巧在我们的项目中会被经常的使用到，例如：处理CSS3的兼容问题</p>
<pre><code>//-&gt;LESS代码
.transition(@property:all;@duration:1s;@function:linear;@delay:0s;) {
  -webkit-transition: @property @duration @function @delay;
  -moz-transition: @property @duration @function @delay;
  -ms-transition: @property @duration @function @delay;
  -o-transition: @property @duration @function @delay;
  transition: @property @duration @function @delay;
}

.box1 {
  .transition;
}

.box2 {
  .transition(@duration: 2s);
}

.box3 {
  .transition(@duration: 2s; @property: width;);
}

//-&gt;编译为CSS的结果
.box1 {
    -webkit-transition: all 1s linear 0s;
    -moz-transition: all 1s linear 0s;
    -ms-transition: all 1s linear 0s;
    -o-transition: all 1s linear 0s;
    transition: all 1s linear 0s;
}

.box2 {
    -webkit-transition: all 2s linear 0s;
    -moz-transition: all 2s linear 0s;
    -ms-transition: all 2s linear 0s;
    -o-transition: all 2s linear 0s;
    transition: all 2s linear 0s;
}

.box3 {
    -webkit-transition: width 2s linear 0s;
    -moz-transition: width 2s linear 0s;
    -ms-transition: width 2s linear 0s;
    -o-transition: width 2s linear 0s;
    transition: width 2s linear 0s;
}
</code></pre><p>此外我们需要值得注意的是，LESS中也有arguments。</p>
<pre><code>//-&gt;LESS代码
.transition(@property:all;@duration:1s;@function:linear;@delay:0s;) {
  -webkit-transition: @arguments;
  transition: @arguments;
}

.box1 {
  .transition;
}

//-&gt;编译为CSS的结果
.box1 {
    -webkit-transition: all 1s linear 0s;
    transition: all 1s linear 0s;
}
</code></pre><p>我们还可以把我们的变量像JS的函数一样操作，不仅仅有参数，还有返回值。</p>
<pre><code>//-&gt;LESS代码
.average(@x, @y) {
  @result: ((@x + @y) / 2);
}

div {
  .average(16px, 50px); //&quot;call&quot; the mixin
  padding: @result; //use its &quot;return&quot; value
}

//-&gt;编译为CSS的结果
div {
    padding: 33px;
}
</code></pre><p>6、Mixin Guards</p>
<p>我们可以在mixin中设置条件；常用的条件运算符：&gt;、&gt;=、&lt;、&lt;=、=；我们设定的条件还可以使用IS函数：iscolor、isnumber、isstring、iskeyword、isurl、ispixel、ispercentage…</p>
<pre><code>//-&gt;LESS代码
.mixin (@a) when (lightness(@a) &gt;= 50%) {
  background-color: black;
}

.mixin (@a) when (lightness(@a) &lt; 50%) {
  background-color: white;
}

.box1{
  .mixin(#ddd);
}

.box2{
  .mixin(#555);
}

//-&gt;编译为CSS的结果
.box1 {
    background-color: black;
}

.box2 {
    background-color: white;
}
</code></pre><p>when是在设置条件，除了像上面的写法外，我们还可以通过when设置多个条件，而且条件中可以使用is函数。</p>
<pre><code>//-&gt;LESS代码:使用IS函数
.mixin (@a; @b: 0) when (isnumber(@b)) { ... }
.mixin (@a; @b: black) when (iscolor(@b)) { ... }

//-&gt;LESS代码:多条件，可以使用and或者逗号间隔
.mixin (@a) when (isnumber(@a)) and (@a &gt; 0) { ... }
.mixin (@a) when (isnumber(@a)) , (@a &gt; 0) { ... }
</code></pre><p>我们还可以通过与&amp;特性结合实现’if’类型的语句。</p>
<pre><code>//-&gt;LESS代码:这里的意思是如果为true,.box的文字颜色才是白色
@my-option: true;
&amp; when (@my-option = true) {
  .box {
    color: white;
  }
}
</code></pre><p>Loops</p>
<p>在Less中，混合可以调用它自身。这样，当一个混合递归调用自己，再结合Guard条件表达式，就可以写出循环结构。使用递归循环最常见的情况就是生成栅格系统的CSS：</p>
<pre><code>//-&gt;LESS代码
.generate-columns(4);
.generate-columns(@n, @i: 1) when (@i &lt;= @n) {
  .column-@{i} {
    width: (@i * 100% / @n);
  }
  .generate-columns(@n, (@i + 1));
}

//-&gt;输出的CSS
.column-1 {
    width: 25%;
}

.column-2 {
    width: 50%;
}

.column-3 {
    width: 75%;
}

.column-4 {
    width: 100%;
}
</code></pre><p>Merge</p>
<p>Merge特性可以从多个属性中将值，集合到某一个样式属性的列表中（也就是多样式效果）。在编写的时候，+代表以逗号分隔，+_代表多个之前以空格分隔。</p>
<pre><code>//-&gt;LESS代码
.mixin() {
  box-shadow+: inset 0 0 10px #555;
}

.myclass {
  .mixin;
  box-shadow+: 0 0 20px black;
}

.mixin2() {
  transform+_: scale(2);
}

.myclass2 {
  .mixin2;
  transform+_: rotate(45deg);
}

//-&gt;输出的CSS
.myclass {
    box-shadow: inset 0 0 10px #555, 0 0 20px black;
}

.myclass2 {
    transform: scale(2) rotate(45deg);
}
</code></pre><p>Parent Selectors</p>
<p>&amp;运算符其实就是让当前的选择器和父级选择器按照特定的规则进行连接，看下面的案例：</p>
<pre><code>//-&gt;LESS代码
.box {
  color: blue;
  &amp;:hover {
    color: green;
  }

  &amp;-top {
    height: 30px;
  }

  &amp;-center {
    height: 500px;
  }

  //-&gt;多个&amp;&amp;
  &amp; + &amp;-top {
    color: red;
  }

  &amp; &amp;-top {
    color: grey;
  }

  &amp;&amp;-top {
    color: black;
  }

  &amp;, &amp;-top {
    color: orange;
  }
}

//-&gt;输出的CSS
.box {
    color: blue;
}

.box:hover {
    color: green;
}

.box-top {
    height: 30px;
}

.box-center {
    height: 500px;
}

.box + .box-top {
    color: red;
}

.box .box-top {
    color: grey;
}

.box.box-top {
    color: black;
}

.box, .box-top {
    color: orange;
}
</code></pre><p>改变选择器顺序，下面的案例中，选择器.no-border-radius &amp;会前置插入它的父选择器.header .menu，最后变成.no-border-radius .header .menu形式输出：</p>
<pre><code>//-&gt;LESS代码
.header {
  .menu {
    border-radius: 5px;
    .no-border-radius &amp; {
      background-image: url(&apos;images/button-background.png&apos;);
    }
  }
}

//-&gt;输出的CSS
.header .menu {
    border-radius: 5px;
}

.no-border-radius .header .menu {
    background-image: url(&apos;images/button-background.png&apos;);
}
</code></pre><p>Import Directives</p>
<p>从其他样式表中导入样式。</p>
<pre><code>//-&gt;LESS代码
@import &quot;public.less&quot;;

.box {
  &amp;:after {
    .clear;
  }
}

//-&gt;输出的CSS:会把public中的样式也输出
.clear {
    display: block;
    height: 0;
    content: &quot;&quot;;
    clear: both;
    zoom: 1;
}

.box:after {
    display: block;
    height: 0;
    content: &quot;&quot;;
    clear: both;
    zoom: 1;
}
</code></pre><p>我们发现上述的操作虽然实现了调取使用，但是会把public中的less也编译到了自己的这个css中，如果不想编译的话，我们需要配置一些参数：</p>
<pre><code>//-&gt;LESS代码
@import (reference) &quot;public.less&quot;;

.box {
  &amp;:after {
    .clear;
  }
}

//-&gt;输出的CSS:
.box:after {
    display: block;
    height: 0;
    content: &quot;&quot;;
    clear: both;
    zoom: 1;
}
</code></pre><p>除了reference以外我们还可以配置一些其他的参数值： inline：在输出中包含源文件但不加工它 less：将文件作为Less文件对象，无论是什么文件扩展名 css：将文件作为CSS文件对象，无论是什么文件扩展名 once：只包含文件一次（默认行为） multiple：包含文件多次</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="[layout]-了解LESS和编译LESS" class="article article-type-[layout]" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/01/了解LESS和编译LESS/" class="article-date">
      <time datetime="2016-03-01T12:00:01.000Z" itemprop="datePublished">2016-03-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/01/了解LESS和编译LESS/">了解LESS和编译LESS</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>   我们大家都知道HTML和CSS不属于编程语言而是属于标记语言，所以很难像JS一样定义变量、编写方法、实现模块化开发等。而目前的CSS编写模式中，都是定义一些公共的样式类名，哪一块的HTML需要这个样式，就去增加对应的样式类名，所以我们经常看到一个标签上存在很多样式类名，在这种模式中我们要时常关注CSS的优先级，避免样式的重叠覆盖…</p>
<p>为了解决CSS的这一困境，CSS预处理预编译的思想脱颖而出，比较具有代表性的有LESS、SASS、Stylus。它们在传统的CSS基础上增加了大量的新的语法，编写方式，常用的函数等，可以让我们的CSS像JS一样成为一门编程语言。基于LESS我么可以把一些经常用到的样式定义成变量或者函数，以后需要直接的调取使用即可，这样不仅有利于增加我们的开发速度，也有利于项目的后期维护与可复用性。</p>
<p>LESS</p>
<p>在这篇文章以及后续的文章中，我将带领去了解LESS，学会使用LESS进行项目的实战开发。LESS是一门CSS预处理语言，它扩展了CSS语言，增加了变量、Mixin、函数等特性，使CSS更易维护和扩展。使用LESS基本上按照这样的步骤：编写LESS代码，使用NODE、JS或者是其他的工具把编写的LESS代码编译成我们平时看到的CSS代码(因为浏览器是无法解析LESS的语法的，所以编写完成的LESS代码需要进行编译)。</p>
<p>[先看一个简单的案例]</p>
<p>在传统的CSS编写中，我们事先为一个盒子.box编写了一套样式，当鼠标滑过的时候，让盒子在原有样式的部分颜色值上发生改变，里面的DIV标签的阴影颜色变重，这样的话我们需要把之前的样式拿过来写一遍，只是调整一下透明度或者颜色值而已，页面中的冗余代码比较的多，也不方便后期的维护。</p>
<pre><code>.box {
    color: #f938ab;
    border-color: #fdcdea;
}

.box1 div {
    -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
}

//-&gt;在:hover触发的时候需要把上述的样式copy一份,在原来的基础上改变部分颜色值和透明度
.box:hover {
    color: #fe33ac;
}

.box:hover div {
    -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
}
</code></pre><p>如果我们使用的是LESS，那么我们可以节省很多的工作，也可以实现可扩展性和通用性，看下面的LESS代码：</p>
<pre><code>//-&gt;定义变量存储颜色值
@color: #f938ab;

//-&gt;你可以把它理解为JS中的一个函数
.box-shadow(@style, @alpha:50%) {
    -webkit-box-shadow: @style rgba(0, 0, 0, @alpha);
    -moz-box-shadow: @style rgba(0, 0, 0, @alpha);
    -ms-box-shadow: @style rgba(0, 0, 0, @alpha);
    -o-box-shadow: @style rgba(0, 0, 0, @alpha);
    box-shadow: @style rgba(0, 0, 0, @alpha);
}

.box {
    color: @color;
    border-color: #fdcdea;

    //-&gt;嵌套:代表是 .box div
    div {
        .box-shadow(0 0 5px, 30%)
    }

    //-&gt;代表的是 .box:hover
    &amp;:hover {
        //-&gt;saturate:LESS提供的颜色处理方法(还有很多其它的方法),用来调整颜色的饱和度变化
        color: saturate(@color, 5%);

        //-&gt;嵌套:代表是 .box:hover div
        div {
            .box-shadow(0 0 5px)
        }
    }
}
</code></pre><p>通过NODE编译后的结果为：</p>
<pre><code>.box {
    color: #f938ab;
    border-color: #fdcdea;
}

.box div {
    -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    -moz-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    -ms-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    -o-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
}

.box:hover {
    color: #fe33ac;
}

.box:hover div {
    -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    -moz-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    -ms-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    -o-box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
}
</code></pre><p>大家感受一下，是不是感觉LESS很强大，一方面不仅仅让我们少些了很多的代码，而且我们定义的变量或者“函数”具有很强的公用性，以后其他的结构需要这样的样式，我们直接的调取就好了。既然认识到了LESS的强大，那么我们接下来就一步步的学会LESS的使用。</p>
<p>LESS的编译</p>
<p>上述我们提到，编写完成的LESS代码是不能直接在浏览器中运行的，需要编译成正常的CSS代码。那么我们首先就来学习一下常用的LESS编译方式。</p>
<p>1、在浏览器中调用LESS.JS</p>
<p>LESS只支持在现代浏览器中运行（最新版本的Chrome, Firefox, Safari 和 IE）。我们不建议在生产环境中使用LESS客户端，因为在将LESS编译成CSS的时候，用户会看到加载延迟的现象，即便在浏览器中有不足一秒的加载延迟，但也会降低性能。</p>
<p>首先引入我们设置样式的LESS文件，注意：这里的rel=’stylesheet/less’</p>
<pre><code>&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet/less&quot; href=&quot;1.less&quot;/&gt;
</code></pre><p>其次为了方便开发过程中的调试(上线后我们也可以配置一些必要的参数)，我们可以在引入LESS.JS之前设置一些配置的参数。我们一般都把所有的配置参数放在全局变量less中。</p>
<pre><code>//-&gt;在引入LESS之前设置一个全局的变量less,配置一些参数值(根据情况自行选择需要配置的项)
var less = {
    //-&gt;evn:设置运行的环境(生产模式还是开发模式)
    //production:编译后的CSS缓存到本地localStorage中
    //development:没有把编译后的CSS缓存到本地,在URL不是标准的格式下(例如:file://...),自动设置为development
    env: &quot;development&quot;,

    //-&gt;logLevel:javascript控制台日志量
    logLevel: 2,

    //-&gt;async:同步或者异步导入文件,默认是false代表同步
    async: false,

    //-&gt;fileAsync:使用文件协议访问页面时异步加载导入的文件,默认是false,如有需要设置为true
    fileAsync: false,

    //-&gt;poll:在监视模式下，每两次请求之间的时间间隔(ms)
    poll: 1000,

    //-&gt;dumpLineNumbers:当设置dumpLineNumbers直接输出源行信息到编译好的CSS的文件中时，有利于你调试指定行。comments参数用于输出用户可以理解的内容，而mediaQuery使用Firefox一个扩展来解析CSS和抽取信息。
    dumpLineNumbers: &quot;comments&quot;,

    //-&gt;relativeUrls：是否调整相对路径。如果为false，则url已经是相对于入口的LESS文件。
    relativeUrls: false
};
//-&gt;还有其它的参数,自己下去后可以再进行扩展
</code></pre><p>然后引入我们的less.js</p>
<pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;less.js&quot;&gt; &lt;/script&gt;
</code></pre><p>最后开启监视模式后,只要我们的LESS改变，在一定时间内，浏览器就会重新的编译，我们可以看到想要的效果</p>
<pre><code>//-&gt;启用监视模式(env必须要设置成development)
less.watch();
</code></pre><p>2、使用NODE命令编译LESS</p>
<p>这种方式是目前项目中最常用的方式，也是我推荐大家使用的方式，它是把我们的LESS文件编译成CSS文件，我们项目中直接的引入CSS文件即可，基本步骤：安装-&gt;编译/压缩编译-&gt;或者使用NODE代码实现批量编译等</p>
<p>把LESS模块安装到全局NODE环境中</p>
<pre><code>npm install less -g
</code></pre><p>使用命令进行编译</p>
<pre><code>//-&gt;把styles.less文件编译成styles.css文件(如果没有这个CSS文件自己会创建)
lessc styles.less styles.css

//-&gt;编译完成的CSS文件是经过压缩的
lessc styles.less styles.min.css -x或者--compress
</code></pre><p>如果你想要更牛X的压缩,还可以自己单独的设定,下面我们使用–clean-css。这个需要提前的安装less-plugin-clean-css模块才可以。</p>
<pre><code>//-&gt;安装less-plugin-clean-css
npm install -g less-plugin-clean-css

//-&gt;安装成功后就可以使用它压缩了
lessc --clean-css styles.less styles.min.css
</code></pre><p>3、在NODE环境中编写批量编译的代码</p>
<p>我们在上述用NODE命令编译的时候，一次只能编译一个文件，这样，如果页面中有多个LESS，每一次编译都是比较耗费时间的，所以我们结合NODE的FS文件读写操作，可以写一套批量编译的代码。</p>
<pre><code>//-&gt;定义编译文件目录和目标导出目录
var dirPath = &quot;./less/&quot;, tarPath = &quot;./css/&quot;;

//-&gt;导入NODE中需要使用的模块
var fs = require(&quot;fs&quot;),
    less = require(&quot;less&quot;);

//-&gt;读取dirPath中的所有文件,检查文件的类型,只有LESS文件我们才进行存储
var ary = [],
    files = fs.readdirSync(dirPath);
files.forEach(function (file, index) {
    /\.(LESS)/i.test(file) ? ary.push(file) : null;
});

//-&gt;把目录下的所有文件进行编译,把编译完成的结果保存在指定的目录中
ary.forEach(function (file) {
    var newFile = file.replace(&quot;.less&quot;, &quot;.css&quot;),
        conFile = fs.readFileSync(dirPath + file, &quot;utf-8&quot;);
    less.render(conFile, {compress: true}, function (error, output) {
        fs.writeFileSync(tarPath + newFile, output.css, &quot;utf-8&quot;);
    });
});
</code></pre><p>4、使用工具编译LESS</p>
<p>目前常用的编译工具有：Koala(据说目前最流行的)、在线编译(<a href="http://tool.oschina.net/less)、SimpLESS等。关于工具的使用，自己下去下载研究即可，非常的简单，本篇文章不做过多的说明。" target="_blank" rel="external">http://tool.oschina.net/less)、SimpLESS等。关于工具的使用，自己下去下载研究即可，非常的简单，本篇文章不做过多的说明。</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2016 冰箱里的水
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题">Yelee</a> by MOxFIVE
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >本站到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.1.22/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>




    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>